# Zmienne (upewnij się, że plik variables.tf zawiera te wartości)
variable "admin_cidr" { default = "0.0.0.0/0" }  # Zmień na swój IP
variable "key_name" { default = "my-key-pair" }
variable "db_password" { default = "TempPass123!" }
variable "instance_type" { default = "t3.micro" }
variable "ami_id" { default = "ami-0abcdef1234567890" }  # Linux AMI dla us-east-1

# VPC
resource "aws_vpc" "main" {
  cidr_block = "10.0.0.0/16"
  tags = { Name = "main-vpc" }
}

# AZs
data "aws_availability_zones" "available" { state = "available" }

locals {
  azs = slice(data.aws_availability_zones.available.names, 0, 2)  # 1a, 1b
}

# Publiczne subnety (10.0.1.0/26 AZa, 10.0.1.64/26 AZb)
resource "aws_subnet" "public" {
  count                   = 2
  vpc_id                  = aws_vpc.main.id
  cidr_block              = cidrsubnet("10.0.0.0/16", 6, 1 + count.index)  # 10.0.1.0/26, 10.0.1.64/26
  availability_zone       = local.azs[count.index]
  map_public_ip_on_launch = true
  tags = { Name = "public-${local.azs[count.index]}" }
}

# Prywatne subnety (10.0.2.0/23 AZa, 10.0.4.0/23 AZb)
resource "aws_subnet" "private" {
  count             = 2
  vpc_id            = aws_vpc.main.id
  cidr_block        = cidrsubnet("10.0.0.0/16", 5, 2 + 2*count.index)  # Dostosowane do opisu
  availability_zone = local.azs[count.index]
  tags = { Name = "private-${local.azs[count.index]}" }
}

# IGW i NAT
resource "aws_internet_gateway" "igw" { vpc_id = aws_vpc.main.id }

resource "aws_eip" "nat" { count = 2 domain = "vpc" }

resource "aws_nat_gateway" "nat" {
  count         = 2
  allocation_id = aws_eip.nat[count.index].id
  subnet_id     = aws_subnet.public[count.index].id
  depends_on    = [aws_internet_gateway.igw]
}

# Route Tables
resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id
  route { cidr_block = "0.0.0.0/0" gateway_id = aws_internet_gateway.igw.id }
}

resource "aws_route_table_association" "public" {
  count          = 2
  subnet_id      = aws_subnet.public[count.index].id
  route_table_id = aws_route_table.public.id
}

resource "aws_route_table" "private" {
  count  = 2
  vpc_id = aws_vpc.main.id
  route {
    cidr_block     = "0.0.0.0/0"
    nat_gateway_id = aws_nat_gateway.nat[count.index].id
  }
}

resource "aws_route_table_association" "private" {
  count          = 2
  subnet_id      = aws_subnet.private[count.index].id
  route_table_id = aws_route_table.private[count.index].id
}

# Security Groups
resource "aws_security_group" "alb" {
  vpc_id = aws_vpc.main.id
  ingress { from_port = 80, to_port = 80, protocol = "tcp", cidr_blocks = ["0.0.0.0/0"] }
  ingress { from_port = 443, to_port = 443, protocol = "tcp", cidr_blocks = ["0.0.0.0/0"] }
  egress { from_port = 0, to_port = 0, protocol = "-1", cidr_blocks = ["0.0.0.0/0"] }
}

resource "aws_security_group" "ec2" {
  vpc_id = aws_vpc.main.id
  ingress { from_port = 80, to_port = 80, protocol = "tcp", security_groups = [aws_security_group.alb.id] }
  ingress { from_port = 443, to_port = 443, protocol = "tcp", security_groups = [aws_security_group.alb.id] }
  ingress { from_port = 22, to_port = 22, protocol = "tcp", security_groups = [aws_security_group.bastion.id] }
  egress { from_port = 0, to_port = 0, protocol = "-1", cidr_blocks = ["0.0.0.0/0"] }
}

resource "aws_security_group" "rds" {
  vpc_id = aws_vpc.main.id
  ingress { from_port = 3306, to_port = 3306, protocol = "tcp", security_groups = [aws_security_group.ec2.id] }  # Zakładam MySQL
  tags = { Name = "rds-sg" }
}

resource "aws_security_group" "bastion" {
  vpc_id = aws_vpc.main.id
  ingress { from_port = 22, to_port = 22, protocol = "tcp", cidr_blocks = [var.admin_cidr] }
  egress { from_port = 0, to_port = 0, protocol = "-1", cidr_blocks = ["0.0.0.0/0"] }
}

# ALB
resource "aws_lb" "alb" {
  name               = "app-alb"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [aws_security_group.alb.id]
  subnets            = aws_subnet.public[*].id
}

resource "aws_lb_target_group" "tg" {
  name     = "app-tg"
  port     = 80
  protocol = "HTTP"
  vpc_id   = aws_vpc.main.id
  health_check { path = "/" }
}

resource "aws_lb_listener" "http" {
  load_balancer_arn = aws_lb.alb.id
  port              = 80
  protocol          = "HTTP"
  default_action { type = "forward", target_group_arn = aws_lb_target_group.tg.id }
}

# WAF (podstawowy)
resource "aws_wafv2_web_acl" "waf" {
  name  = "app-waf"
  scope = "REGIONAL"
  default_action { allow {} }
  rule {
    name     = "aws-managed-rules-common-rule-set"
    priority = 1
    override_action { none {} }
    statement { managed_rule_group_statement { vendor_name = "AWS", name = "AWSManagedRulesCommonRuleSet" } }
  }
}

resource "aws_wafv2_web_acl_association" "waf_assoc" {
  resource_arn = aws_lb.alb.arn
  web_acl_arn  = aws_wafv2_web_acl.waf.arn
}

# Launch Template dla ASG
resource "aws_launch_template" "ec2" {
  name_prefix   = "app-"
  image_id      = var.ami_id
  instance_type = var.instance_type
  key_name      = var.key_name
  vpc_security_group_ids = [aws_security_group.ec2.id]
  user_data = base64encode("#!/bin/bash\necho 'Hello from EC2'")
}

# ASG
resource "aws_autoscaling_group" "asg" {
  desired_capacity = 2
  max_size         = 4
  min_size         = 2
  vpc_zone_identifier = aws_subnet.private[*].id
  target_group_arns   = [aws_lb_target_group.tg.arn]
  health_check_type   = "ELB"
  health_check_grace_period = 300
  launch_template { id = aws_launch_template.ec2.id }
}

# Bastion
resource "aws_instance" "bastion" {
  ami           = var.ami_id
  instance_type = "t3.micro"
  subnet_id     = aws_subnet.public[0].id
  vpc_security_group_ids = [aws_security_group.bastion.id]
  key_name      = var.key_name
  tags = { Name = "bastion" }
}

# RDS Multi-AZ
resource "aws_db_subnet_group" "rds" {
  name       = "rds-subnet-group"
  subnet_ids = aws_subnet.private[*].id
}

resource "aws_db_instance" "main" {
  identifier              = "app-db"
  engine                  = "mysql"
  engine_version          = "8.0"
  instance_class          = "db.t3.micro"
  allocated_storage       = 20
  max_allocated_storage   = 100
  storage_encrypted       = true
  kms_key_id              = aws_kms_key.rds.arn  # Utwórz KMS key
  db_subnet_group_name    = aws_db_subnet_group.rds.name
  vpc_security_group_ids  = [aws_security_group.rds.id]
  multi_az                = true
  backup_retention_period = 14
  password               = var.db_password
  skip_final_snapshot     = true
}

# Secrets Manager (podstawowy sekret DB)
resource "aws_secretsmanager_secret" "db_creds" {
  name = "db-creds"
}

resource "aws_secretsmanager_secret_version" "db_creds_version" {
  secret_id     = aws_secretsmanager_secret.db_creds.id
  secret_string = jsonencode({ username = "admin", password = var.db_password })
}

# KMS dla RDS (prosty)
resource "aws_kms_key" "rds" { description = "RDS KMS key" }